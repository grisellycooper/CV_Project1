///*** Fronto-Parallel thing
    bool ba = true;
        
    for(int iter = 0; iter < 5; iter++){
        std::vector<std::vector<cv::Point2f>> imagePoints2;    
        std::vector<cv::Point2f> pointbuf2;
        cv::Mat temp;    
        bool found2 = false;
        
        std::vector<std::vector<cv::Point3f>> objectPoints(1);                
        getControlPointsPositions(patternSizes[pattern], ctrlPointDistances[pattern], objectPoints[0], pattern);
        objectPoints.resize(imagePoints.size(),objectPoints[0]);

        std::cout<<"------ Fronto-Parallel thing" <<std::endl;
        
        std::vector<cv::Mat> rvecs2;
        std::vector<cv::Mat> tvecs2;
        cv::Mat cameraMatrix2;
        cv::Mat distCoeffs2;
    
        rms = calibrateCamera(objectPoints, imagePoints, cv::Size(frWidth,frHeight), cameraMatrix2, distCoeffs2, rvecs2, tvecs2);
        std::cout << "RMS error reported by calibrateCamera: " << rms << std::endl;   
        std::cout << "Intrinsic camera matrix" << std::endl << cameraMatrix2 << std::endl;
        std::cout << "Distortion coefficients" << std::endl << distCoeffs2 << std::endl;
        std::cout << "----------------------------" << std::endl;
  
        
        std::vector<cv::Point2f> fronto_corners = getFrontoParallelCorners(cv::Size(frWidth, frHeight),patternSizes[pattern]);
            
        for(int i=0; i<selectedFrames.size(); i++){
            //---------------------------------         
            /// Undistort and Unproject
            /// find grid
            /// ProjectControlPoints
            /// Calibrate camera                    
            
            ///*** Undistort image ***///
            cv::Mat frame2 = selectedFrames[i]; 
            temp = frame2.clone();
            cv::Mat OptimalMatrix = cv::getOptimalNewCameraMatrix(cameraMatrix2, distCoeffs2, cv::Size(frWidth,frHeight), 1.0);
            cv::undistort(temp,frame2,cameraMatrix2,distCoeffs2,OptimalMatrix);                    
            cv::undistortPoints(imagePoints[i], pointbuf2, cameraMatrix2, distCoeffs2, cv::noArray(), OptimalMatrix);

            
            std::cout<<"buf: " <<pointbuf2.size() <<std::endl;
            std::vector<cv::Point2f> corners1 = extractCorners(pointbuf2,patternSizes[pattern]);
            //std::cout<<"   - cor: " <<corners1.size();
            /*cv::Mat a = cv::Mat::zeros(frame.rows, frame.cols, CV_8UC3);
            for (int i = 0; i < fronto_corners.size(); i++)
            {
                std::cout<<"x,y: " <<fronto_corners[i].x <<", "<< fronto_corners[i].y <<std::endl;
                circle(a, fronto_corners[i], 1, cv::Scalar(0, 0, 255), 4, 8);
                //cv::putText(test1, std::to_string(i), tmpCenters[i], cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(250, 0, 0), 2);
            }

            cv::namedWindow("1", cv::WINDOW_NORMAL); 
            imshow("1", a);
            */
            /*cv::Mat b = cv::Mat::zeros(frame.rows, frame.cols, CV_8UC3);
            for (int i = 0; i < corners1.size(); i++)
            {
                std::cout<<"x,y: " <<corners1[i].x <<", "<< corners1[i].y <<std::endl;
                circle(b, corners1[i], 1, cv::Scalar(0, 0, 255), 4, 8);
                //cv::putText(test1, std::to_string(i), tmpCenters[i], cv::FONT_HERSHEY_DUPLEX, 0.5, cv::Scalar(250, 0, 0), 2);
            }

            cv::namedWindow("2", cv::WINDOW_NORMAL); 
            imshow("2", b);
            */
            cv::Mat H = cv::findHomography(corners1,fronto_corners);
	        cv::Mat imgWarp;
	        cv::warpPerspective(frame2,imgWarp,H,frame2.size());
	        
            cv::namedWindow("ImgWarp", cv::WINDOW_NORMAL); 
            imshow("ImgWarp", imgWarp);
            
            pointbuf2.clear();		
            contours.clear();
            hierarchy.clear();
            found2 = false;
            ///**** PREPROCESSING IMAGE ****///
            preprocessImage(imgWarp, view, contours, hierarchy);
            //std::cout<<"Contours: "<<contours.size()<<std::endl;
            //std::cout<<"Hierarchy: "<<hierarchy.size()<<std::endl;

            ///*** IDENTIFY RINGS ***///
            identifyRings2(contours, hierarchy, pointbuf2, patternSize, imgWarp);
            std::cout<<"PointBufferSize: "<<pointbuf2.size()<<"  ";
            
            if(ba)
            {
            
                ///*** FIND RINGS GRID ***///
                if (pointbuf2.size() == patternSize)
                {   
                    found2 = findRingsGrid(imgWarp, patternSizes[pattern], pointbuf2, pointbuf2, false);                   
                }

                if(!found2){
                    std::cout << "Not found in the parallel frame!\n";
                }
                else{
                    //std::cout << "Albricias!" <<std::endl;
                }

                //Transformacion Fronto Parallel Inversa
                cv::Mat imgWarp_inv;
                cv::warpPerspective(imgWarp,imgWarp_inv,H.inv(),imgWarp.size());

                std::vector<cv::Point2f> points_buffer2;

                cv::perspectiveTransform( pointbuf2, points_buffer2, H.inv() );

                std::vector<cv::Point2f> corrected_points;

                // Distorsi√≥n Inversa
                cv::undistortPoints(points_buffer2,corrected_points,OptimalMatrix,-distCoeffs2,cv::noArray(),cv::noArray());
                

                cv::drawChessboardCorners(imgWarp_inv, patternSizes[pattern], corrected_points, true);
                cv::drawChessboardCorners(imgWarp_inv, patternSizes[pattern], imagePoints[i], true);
                
                imagePoints2.push_back(corrected_points);

                cv::namedWindow("ImgWarp Inv", cv::WINDOW_NORMAL); 
                imshow("ImgWarp Inv", imgWarp_inv);

                for(int j=0; j<patternSize; j++){
                   imagePoints[i][j].x = (imagePoints[i][j].x +  imagePoints2[i][j].x) / 2.0;
				    imagePoints[i][j].y = (imagePoints[i][j].y +  imagePoints2[i][j].y) / 2.0;
                }  
            }

            cv::namedWindow("Video Display 2", cv::WINDOW_NORMAL);
            imshow("Video Display 2", frame2);

            if (cv::waitKey() == 27)
                cv::waitKey(100);

            
        }
        ba = false;            
    }
    


///Camara 1

RMS error reported by calibrateCamera: 0.203021
Intrinsic camera matrix
[677.1168391520956, 0, 333.525353774886;
 0, 674.5824419273299, 278.0605557446987;
 0, 0, 1]
Distortion coefficients
[-0.3215992677381339, -0.1330194679228761, -0.004595325963933461, 0.0001005611521560389, 0.5449913351083483]
----------------------------

///Camara 2

RMS error reported by calibrateCamera: 0.235633
Intrinsic camera matrix
[542.6320595135309, 0, 299.9661232435349;
 0, 537.5177415623733, 176.2603033655279;
 0, 0, 1]
Distortion coefficients
[0.04274915902484682, 0.05358890675723066, 0.01193750029100565, -0.02343725016080278, -0.1360904818274421]
----------------------------
frame capturado: 1





















------------------------------------------
///*** Fronto-Parallel Calibration ***///

    std::vector<std::vector<cv::Point2f>> imagePoints2;    
    std::vector<cv::Point2f> pointbuf2;

    
    
    cv::Mat imgWarp_inv;
    cv::Mat imgWarp;
    std::vector<cv::Point2f> corrected_points;
    std::vector<cv::Point2f> points_buffer2;

    //std::vector<cv::Point2f> corners;  
        
    std::vector<cv::Point2f> fronto_corners = getFrontoParallelCorners(cv::Size(frWidth, frHeight),patternSizes[pattern]);

    cv::Mat temp;    
    bool found2;        
    bool flag = false;
    
    
for(int iter = 0; iter < 5; iter++){
        std::vector<cv::Mat> rvecs2;
        std::vector<cv::Mat> tvecs2;
        cv::Mat cameraMatrix2;
        cv::Mat distCoeffs2;

        std::vector<std::vector<cv::Point3f>> objectPoints(1);                
        getControlPointsPositions(patternSizes[pattern], ctrlPointDistances[pattern], objectPoints[0], pattern);
        objectPoints.resize(imagePoints.size(),objectPoints[0]);
    
        std::cout<<"------ Fronto-Parallel Calibration" <<std::endl;
        
        rms = calibrateCamera(objectPoints, imagePoints, cv::Size(frWidth,frHeight), cameraMatrix2, distCoeffs2, rvecs2, tvecs2);
        std::cout << "RMS error reported by calibrateCamera: " << rms << std::endl;   
        std::cout << "Intrinsic camera matrix" << std::endl << cameraMatrix2 << std::endl;
        std::cout << "Distortion coefficients" << std::endl << distCoeffs2 << std::endl;
        std::cout << "----------------------------" << std::endl;

        //***** Iterative Refinement Method
        /// Undistort and Unproject
        /// find grid
        /// ProjectControlPoints
        /// Calibrate camera                    
             
        for(int i=0; i<selectedFrames.size(); i++){
            
            ///*** Undistort image ***///
            cv::Mat frame2 = selectedFrames[i]; 
            temp = frame2.clone();
            cv::Mat OptimalMatrix = cv::getOptimalNewCameraMatrix(cameraMatrix2, distCoeffs2, cv::Size(frWidth,frHeight), 1.0);
            cv::undistort(temp,frame2,cameraMatrix2,distCoeffs2,OptimalMatrix);                    
            cv::undistortPoints(imagePoints[i], pointbuf2, cameraMatrix2, distCoeffs2, cv::noArray(), OptimalMatrix);
            
            std::cout<<"imagePoints - new pointbuffer" <<std::endl;
            for(int l = 0; l < pointbuf2.size(); l++){
                std::cout<<" " <<imagePoints[i][l].x <<", " <<imagePoints[i][l].y <<"  /-/  " <<pointbuf2[l].x <<", " <<pointbuf2[l].y<<std::endl;            
            }

            cv::namedWindow("Video Display 2", cv::WINDOW_NORMAL);
            imshow("Video Display 2", frame2);

            std::cout<<"buf: " <<pointbuf2.size() <<std::endl;
            
            std::vector<cv::Point2f> corners = getPatternCorners(pointbuf2,patternSizes[pattern]);
            
            std::cout<<"corners: " <<corners.size() <<std::endl;
            for(int j = 0; j < corners.size(); j++){
                std::cout<<"x,y " <<corners[j].x <<", " <<corners[j].y <<std::endl;            
            }

            for(int k = 0; k < fronto_corners.size(); k++){
                std::cout<<"x,y " <<fronto_corners[k].x <<", " <<fronto_corners[k].y <<std::endl;            
            }

            cv::Mat H = cv::findHomography(corners,fronto_corners);	        
	        cv::warpPerspective(frame2,imgWarp,H,frame2.size());
	        
            cv::namedWindow("ImgWarp", cv::WINDOW_NORMAL); 
            imshow("ImgWarp", imgWarp);            

            ///*** Find pattern ***///
            pointbuf2.clear();		
            contours.clear();
            hierarchy.clear();
            found2 = false;

            preprocessImage(imgWarp, view, contours, hierarchy);
            identifyRings2(contours, hierarchy, pointbuf2, patternSize, imgWarp);
            std::cout<<"PointBufferSize: "<<pointbuf2.size()<<"  ";
            
            if(flag){
                if (pointbuf2.size() == patternSize)
                {   
                    found2 = findRingsGrid(imgWarp, patternSizes[pattern], pointbuf2, pointbuf2, false);                                   
                }

                if(found2){
                    cv::warpPerspective(imgWarp,imgWarp_inv,H.inv(),imgWarp.size());                
                    cv::perspectiveTransform( pointbuf2, points_buffer2, H.inv() );
                    cv::undistortPoints(points_buffer2,corrected_points,OptimalMatrix,-distCoeffs2,cv::noArray(),cameraMatrix2);
                
                    imagePoints2.push_back(corrected_points);

                    cv::drawChessboardCorners(imgWarp_inv, patternSizes[pattern], corrected_points, found);
                    std::cout<<"corrected_points" <<std::endl;
                    for(int m = 0; m < corrected_points.size(); m++){
                        std::cout<<" " <<corrected_points[m].x <<", " <<corrected_points[m].y <<std::endl;            
                    }
                }
                else{
                    std::cout << "Not found in the parallel frame!\n";
                }

                
                /*std::cout<<"points_buffer2: "<<points_buffer2.size()<<"  ";                
                std::cout<<"corrected_points: "<<corrected_points.size()<<"  ";                */
                    //cv::drawChessboardCorners(imgWarp_inv, patternSizes[pattern], corrected_points, true);
                
                cv::namedWindow("ImgWarp Inv", cv::WINDOW_NORMAL); 
                imshow("ImgWarp Inv", imgWarp_inv);

                 
            }

            if (cv::waitKey() == 27)
                cv::waitKey(100);

                
        }
        imagePoints.clear();
        imagePoints = imagePoints2;
        std::cout<<"imagePoints: "<<imagePoints.size()<<"  ";

        flag = false;
    }

    